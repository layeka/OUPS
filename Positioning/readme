反向标定：
涉及文件：NodePosition.cpp NodePosition.h


使用方法：
./cal config < rev_data


思想：
主要分三大步骤：
1，获取一组稳定(稳定是指至少4个以上的节点数据保持在小范围内波动)的tag数据，目前一组数据包括Loops_of_data轮数据,每一轮数据至多有max_rx_num个distance;
2,当获得足够多组的关于同一tag的数据时，则计算tag本身的坐标值（前4个不需要计算，由三脚架确定，tag1,tag2,tag3位于底面，tag4位于
  顶端，tag1指示x轴方向，tag2指示y轴方向，tag3指示z轴方向，原点位于底面等边三角形的重心位置）.
3,依次遍历计算每一个receiver的位置，它是由一组包含多轮距离信息计算得到，其中的belief表示可信度，越低越好，0是初始值，视为无效值。
4,若3计算完后，仍有节点尚未被定位,或计算结果不理想，则跳到1。


存在问题：
计算精度不高，主要原因是,
    1,一组数据采集的量太小(目前是15);
    2,偏移角度太大的distance不应参与反向定位；

